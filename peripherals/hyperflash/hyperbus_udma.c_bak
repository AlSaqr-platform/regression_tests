#include <stdio.h>
#include <rt/rt_api.h>
#include </home/hayate/pulpissimo-github/pulp-sdk/runtime/pulp-rt/include/rt/rt_freq.h>
#include <stdint.h>
//#include </home/vivid/pulpissimo/pulp-sdk/runtime/hal/include/hal/eu/eu_v3.h>

#define pulp_write32(add, val_) (*(volatile unsigned int *)(long)(add) = val_)

#define BUFFER_SIZE 64
int tx_buffer[BUFFER_SIZE];
int rx_buffer[BUFFER_SIZE];

int tx_buffer2[BUFFER_SIZE];
int rx_buffer2[BUFFER_SIZE];

//int __rt_fpga_fc_frequency = 20000000; // e.g. 20000000 for 20MHz;
//int __rt_fpga_periph_frequency = 10000000; // e.g. 10000000 for 10MHz;

/** UDMA Global configuration - Register Layout Typedef */
typedef struct {
  unsigned int CG;                          /**< UDMA_GC clock gating register, offset: 0x0 */
  unsigned int EVTIN;                       /**< UDMA_GC input event register, offset: 0x04 */
} UDMA_GC_Type;


/* Find your own SOC_PERI_BASE  */
#define SOC_PERI_BASE                         0x1a100000
#define UDMA_OFFSET                           0x02000u
#define UDMA_BASE                            (SOC_PERI_BASE + UDMA_OFFSET)
#define HYPERBUS_BASE                         128 * 9
#define HYPERBUS_DEVICE_NUM                   8

/* Find your own UDMA_GC_addr  */
//#define UDMA_GC_BASE                         (UDMA_BASE + 0x780u)
#define UDMA_GC_BASE                         (UDMA_BASE)

#define UDMA_CFG_EN_MASK                     (0x10U)
#define UDMA_CFG_EN_SHIFT                    (4U)
#define UDMA_CFG_EN(x)                       (((unsigned int)(((unsigned int)(x)) << UDMA_CFG_EN_SHIFT)) & UDMA_CFG_EN_MASK)//

int main() {

    int a;
    int *p;
    //rt_freq_set(__RT_FREQ_DOMAIN_CL, 330000000);
    pulp_write32(UDMA_GC_BASE + 0x00, 1 << HYPERBUS_DEVICE_NUM);
    
    //rt_freq_set(__RT_FREQ_DOMAIN_FC,     100000000);
    //rt_freq_wait_convergence(__RT_FREQ_DOMAIN_PERIPH);
    printf(" current frequency %d \n", __rt_freq_periph_get());
    ///*CDR loop configuration setup*/

    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x4C, 0x01 ); // 2D TRAN is deactivated
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x50, 0x10 ); // 2D count is specified
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x54, 0x20 ); // 2D stride is specified
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x38, 0x01 ); // REG_T_VARI_LATENCY 
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x28, 0x00 ); // REG_EN_LATENCY_ADD 
   // pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x24, 0x06 ); // REG_T_LATENCY_ACCESS 

    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x20, 0x00 ); // PAGE_BOUNDARY 
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x2C, 0xffffffff ); // REG_T_CS_MAX
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x0C, (unsigned int)tx_buffer ); // TX START ADDR
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x10, BUFFER_SIZE*4 ); // TX SIZE
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x1C, 0x02 ); // HYPER RAM START ADDRESS
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x18, 0x01 ); // CA SETUP FOR HYPERBUS PROTOCOL

    p = UDMA_BASE +HYPERBUS_BASE + 0x38;
    printf("REG_T_VARI_LATENCY: %x \n",*p);
    p = UDMA_BASE +HYPERBUS_BASE + 0x20;
    printf("PAGE_BOUND: %x \n",*p);
    p = UDMA_BASE +HYPERBUS_BASE + 0x0C;
    printf("TX_START_ADDR: %x \n",*p);
    p = UDMA_BASE +HYPERBUS_BASE + 0x10;
    printf("TX_SIZE: %x \n",*p);
   
    for (int i=0; i< (BUFFER_SIZE); i++)
    {
        tx_buffer[i] = 0xffff0000+i;
        //printf("tx_buffer[%d] = %x \n", i, tx_buffer[i]);
    } 
 
/*    p = UDMA_BASE + HYPERBUS_BASE + 0x14;
    *p=0x14; */

    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x14, 0x14 ); // WRITE TRANSACTION IS KICKED
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x14, 0x14 ); // WRITE TRANSACTION IS KICKED
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x14, 0x14 ); // WRITE TRANSACTION IS KICKED
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x14, 0x14 ); // WRITE TRANSACTION IS KICKED
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x14, 0x14 ); // WRITE TRANSACTION IS KICKED
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x14, 0x14 ); // WRITE TRANSACTION IS KICKED
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x14, 0x14 ); // WRITE TRANSACTION IS KICKED
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x14, 0x14 ); // WRITE TRANSACTION IS KICKED
    //p = UDMA_BASE +HYPERBUS_BASE + 0x58;
    //printf("NB_TRAN: %d \n",*p>>1);
    a=pulp_read32(UDMA_BASE +HYPERBUS_BASE + 0x58);
    printf("NB_TRAN: %d \n", a/2);
   // pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x14, 0x14 ); // WRITE TRANSACTION IS KICKED
   // pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x14, 0x14 ); // WRITE TRANSACTION IS KICKED


    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x4C, 0x00 ); // 2D TRAN is deactivated
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x00, (unsigned int)rx_buffer ); // RX_START_ADDR
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x04, BUFFER_SIZE*4 ); // RX_SIZE
    p = UDMA_BASE +HYPERBUS_BASE + 0x38;
    printf("REG_T_VARI_LATENCY: %x \n",*p);
    p = UDMA_BASE +HYPERBUS_BASE + 0x20;
    printf("PAGE_BOUND: %x \n",*p);
    p = UDMA_BASE +HYPERBUS_BASE + 0x0C;
    printf("TX_START_ADDR: %x \n",*p);
    p = UDMA_BASE +HYPERBUS_BASE + 0x10;
    printf("TX_SIZE: %x \n",*p);

    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x1C, 0x02 ); // HYPER RAM START ADDRESS
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x18, 0x05 ); // CA SETUP FOR HYPERBUS PROTOCOL
    
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x08, 0x14 ); // READ TRANSACTION IS KICKED
    pulp_write32(UDMA_BASE +HYPERBUS_BASE + 0x08, 0x00 ); // CLEAN UP THE RXCFG
 
for (volatile int i=0; i<100; i++);

for (int i=0; i< BUFFER_SIZE; i++)
  {      
   //if(rx_buffer[i]!=tx_buffer[i]){
      printf("rx_buffer[%d] = %x \n", i, rx_buffer[i]);
   //}
}
 
return 0;
  
    
}
