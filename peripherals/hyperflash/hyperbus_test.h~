#include <pulp.h>

#define UDMA_HYPERBUS_OFFSET 0x1a102000+128*9
#define HYPERBUS_DEVICE_NUM 8

static inline void udma_hyper_setup(){
  pulp_write32(0x1a102000, 1 << HYPERBUS_DEVICE_NUM); // clock for the hyper bus module is activated
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x4C, 0x00 ); // 2D TRAN is deactivated
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x28, 0x01 ); // REG_T_EN_LATENCY_ADD
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x2C, 0xffffffff ); // REG_T_CS_MAX
}

static inline void udma_hyper_sleep(){
  int a;
  a = pulp_read32(0x1a102000);
  pulp_write32(0x1a102000, (1 << HYPERBUS_DEVICE_NUM)^a ); // Clock gating is activated
}

// Linear write is conducted. len <- burst length in bytes, ext_addr <- start address of the external memory, l2_addr <- start_address of the L2 memory, page_bound <- page boundary in the external memory
static inline void udma_hyper_dwrite(unsigned int len, unsigned int ext_addr, unsigned int l2_addr, unsigned int page_bound){

  switch(page_bound){
     case 128: 
        pulp_write32(UDMA_HYPERBUS_OFFSET + 0x20, 0x00 ); // page boundary is set to every 128 bytes
        break;
     case 256:
        pulp_write32(UDMA_HYPERBUS_OFFSET + 0x20, 0x01 ); // page boundary is set to every 256 bytes
        break;
     case 512:
        pulp_write32(UDMA_HYPERBUS_OFFSET + 0x20, 0x02 ); // page boundary is set to every 128 bytes
        break;
     case 1024:
        pulp_write32(UDMA_HYPERBUS_OFFSET + 0x20, 0x03 ); // page boundary is set to every 256 bytes
        break;
     default:
        pulp_write32(UDMA_HYPERBUS_OFFSET + 0x20, 0x00 ); // page boundary is not considered
  }

  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x0C, l2_addr ); // Data address 
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x10, len );     // Data size to be sent
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x1C, ext_addr );     // Data size to be sent
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x18, 0x01);     // Write is declared for the external mem
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x14, 0x14);     // Write transaction is kicked
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x14, 0x00);     // Write transaction information is reset
}

// Linear read is conducted. len <- burst length in bytes, ext_addr <- start address of the external memory, l2_addr <- start_address of the L2 memory, page_bound <- page boundary in the external memory
//

static inline void udma_hyper_dread(unsigned int len, unsigned int ext_addr, unsigned int l2_addr, unsigned int page_bound){
  
  switch(page_bound){
     case 128:
        pulp_write32(UDMA_HYPERBUS_OFFSET + 0x20, 0x00 ); // page boundary is set to every 128 bytes
        break;
     case 256:
        pulp_write32(UDMA_HYPERBUS_OFFSET + 0x20, 0x01 ); // page boundary is set to every 256 bytes
        break;
     case 512:
        pulp_write32(UDMA_HYPERBUS_OFFSET + 0x20, 0x02 ); // page boundary is set to every 128 bytes
        break;
     case 1024:
        pulp_write32(UDMA_HYPERBUS_OFFSET + 0x20, 0x03 ); // page boundary is set to every 256 bytes
        break;
     default:
        pulp_write32(UDMA_HYPERBUS_OFFSET + 0x20, 0x00 ); // page boundary is not considered
  }

  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x00, l2_addr ); // Data address 
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x04, len );     // Data size to be sent
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x1C, ext_addr );     // Data size to be sent
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x18, 0x05);     // Read is declared for the external mem
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x08, 0x14);     // Read transaction is kicked
  pulp_write32(UDMA_HYPERBUS_OFFSET + 0x08, 0x00);     // Write transaction information is reset
}

// Outputs the number of transactions which is remaining the FIFO
static inline int udma_hyper_nb_tran(){
  int a;
  return pulp_read32(UDMA_HYPERBUS_OFFSET + 0x58) >> 1;
}

// If the hyperbus module is doing something.
static inline int udma_hyper_busy(){
  return pulp_read32(UDMA_HYPERBUS_OFFSET + 0x58) & 0x00000001;
}

static inline void udma_hyper_wait(){
   while(udma_hyper_busy()){
   }
}
